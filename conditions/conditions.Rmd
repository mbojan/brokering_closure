---
title: "Error handling and recovery"
bibliography: restarts.bib
output: 
  html_document:
    toc: true
    highlight: pygment
    number_sections: true
---


---

These are R musings on handling exceptions and creating recovery protocols.

```{r setup, cache=FALSE}
library(xml2)
library(knitr)
opts_chunk$set( error=TRUE )
```




# Error catching and creating custom conditions

As a preliminary, let's define two useful functions from [^1] that can be used to create custom conditions.

[^1]: Hadley Wickham, Advanced R http://adv-r.had.co.nz/Exceptions-Debugging.html#condition-handling

```{r condition_generator}
condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure(
    class = unique(c(subclass, "condition")),
    list(message = message, call = call),
    ...
  )
}

is.condition <- function(x) inherits(x, "condition")
```



## Catching errors from `xml2::read_xml`

How to catch an error and define new types.

`read_xml` sometimes throws an error generated by `libxml` that signal an illegal character in the XML being parsed. It might be useful to differentiate this type of errors from others as they can be handled differently. Let's start with some example data:

```{r read_xml_data}
inputs <- list(
  good = "<p>A proper paragraph with some <b>bold</b> letters.</p>",
  bad1 = paste0("<p>", intToUtf8(25), " and ", intToUtf8(7), "</p>"),
  bad2 = "<p>Malformed XML with a missing closing tag"
)
```

Try parsing:

```{r}
lapply(inputs, function(x)  read_xml(x))
```

whats going on:

```{r}
str( lapply(inputs, function(x)  try(read_xml(x))) )
```



We can use `tryCatch` to fish-out the "invalid Char value" errors like this:

```{r read_xml_with_errors}
read_xml_with_errors <- function(x, ...) {
  # Handle Rcpp exceptions,
  # which include libxml errors
  handle_rcpp_exception <- function(cond) {
    # better error message
    cond$message <- paste("xml2::read_xml says:", cond$message)
    # enhance for selected errors
    if(grepl("PCDATA invalid Char value", cond$message)) {
      cond <- condition(
        subclass=c("invalid_char_value", class(cond)),
        message = cond$message,
        call=cond$call,
        error_no = as.numeric(stringr::str_extract(cond$message, "(?<=\\[)[0-9]+(?=\\]$)" )),
        char_value = as.numeric(stringr::str_extract(cond$message, "(?<=value )[0-9]+(?= \\[)" ))
      )
    }
    stop(cond)
  }
  
  # Catch!
  tryCatch( xml2::read_xml(x, ...),
            "Rcpp::exception" = handle_rcpp_exception
  )
}
```

Function `tryCatch` looks at conditions thrown by `read_xml`. If the condition is of class "Rcpp::exception" a handler function `handle_rcpp_exception` is executed. This function looks at the message of the original condition. If it looks like "PCDATA invalid Char value" it extracts the value of the invalid character and the error number (in square brackets in the original message). A new condition object is created of class `"invalid_char_value"` which extends the original class `"Rcpp::exception"`. Extracted offending character value and error number are added as attributes to the new condition. Finally, the condition is signalled.

Conditions not caught by `tryCatch`, so all others apart from `"Rcpp::exception"`s, are signaled as usual.

For example:

```{r}
str( lapply(inputs, function(x) try(read_xml_with_errors(x))) )
```

So now for `bad` we have (1) special condition class and (2) extracted information about invalid character and error number.



## Recovering from (some of) `read_xml` errors

Given that we singled-out invalid character errors we can try to use that information to recover, e.g.:

- Fix the input file by removing or escaping offending characters and re-parse it again.
- Write the offending XML to a file for further inspection.

The following example removes the offending characters and tries to re-parse the XML again

```{r read_xml_safely}
read_xml_safely <- function(x, ...) {
  repeat {
    tryCatch( return(read_xml_with_errors(x, ...)),
              # Removing offending characters
              invalid_char_value = function(er) {
                charint <- attr(er, "char_value")
                x <<- gsub(intToUtf8(charint), "", x)
                msg <- paste0(er$message, ", removing offending characters")
                warning(msg)
              }
    )
  }
}
```

Let's try it:

```{r}
read_xml_safely( inputs$bad1 )
```

```{r}
str( lapply(inputs, function(x) try(read_xml_safely(x))) )
```

So now, after retries, `bad1` is parsed correctly.




# Restarts

```{r}
f <- function(x) {
  repeat {
    withRestarts( return(log(x)),
                  fixx = function(newx) x <<- newx
    )
  }
}
```



```{r}
inputs <- list(1, -1, "a")

for( i in inputs )
  withCallingHandlers(  cat("input: ", i, "result: ", f(i), "\n"),
                        warning = function(w) invokeRestart("fixx", 0),
                        error = function(w) invokeRestart("fixx", 1)
  )
```



# Getting `resumptionToken` with regular expressions



```{r}
x <- paste(readLines("some.xml"), collapse="")
offending <- paste(readLines("offending.txt"), collapse="")
html <- xml2::read_html(offending)
xml2::xml_text(xml2::xml_find_all(html, "//resumptiontoken"))
```
  



















# Examples from others

## Code from win-vector blog

An example from [^2] showing of the use of `tryCatch` and `withRestarts`.

[^2]: Win-Vector blog http://www.win-vector.com/blog/2012/10/error-handling-in-r

```{r eval=FALSE}
# argument x: item to take logarithm of
# argument warning: warning handler
# argument error: error handler
# invokeRestart("flipArg"): re-runs function on -x if x 
#    (appropriate fix for negative numeric arguments)
# invokeRestart("zapOutArg"): re-runs function on x=1 
#    (appropriate fix for non-numeric arguments)
expensiveBigLibraryFunction <- function(x,
                                        warning=function(w) {
                                          print(paste('warning:',w)); 
                                          browser()},
                                        error=function(e) {
                                          print(paste('e:',e)); 
                                          browser()}
) 
{
  print(paste("big expensive step we don't want to repeat for x:",x))
  z <- x  # the "expensive operation" 
  # (not really, just standing in for computation)
  repeat 
    withRestarts(
      withRestarts(
        tryCatch(   # you could call withCallingHandlers 
          # with identical arguments here, too
          {
            print(paste("attempt cheap operation for z:",z))
            return(log(z))
          },
          warning = warning,
          error = error ),
        flipArg = function() {z <<- -z} ),
      zapOutArg = function() {z <<- 1} )
}
```

And now:

```{r, eval=FALSE}
expensiveBigLibraryFunction(1)

expensiveBigLibraryFunction(-10)
computeRestarts()
invokeRestart("flipArg")

```
