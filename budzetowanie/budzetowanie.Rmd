---
title: "Budżetowanie"
author: "Michał Bojanowski"
output: 
  html_document:
    highlight: pygments
---

```{r setup, include=FALSE, cache=FALSE}
library(tibble)
library(dplyr)
library(mouter)

set.seed(0)
```

Budżet wymaga:

1. Harmonogram: łączne koszty zadań.
2. Kosztorys: łączne koszty przez lata w rozbiciu na osobowe i nieosobowe.
3. Personel: łączne koszty zatrudnienia poszczególnych osób.

W utopijnym świecie każdą złotówkę w projekcie można przyporządkować wg następujących zmiennych:

- `rok` projektu
- `zadanie` projektu
- `osoba` lub ogólnie "kontrahent" (musi obejmować nieosobowe koszty). Dzielą się na `kategoria= "osobowe"` i `kategoria="nieosobowe"`.
- `kategoria` koszty osobowe i nieosobowe

Jednocześnie, prezentacja budżetu wymaga wykazania jedynie czterech rozkładów sum brzegowych:

1. Rozkładu brzegowego `zadanie`
2. Rozkładu brzegowego `rok` x `kategoria`
3. Rozkładu brzegowego `osoba`

Przykładowy budżet jako rozkład łączny:

```{r dane}
load("recon.rda")

head(budzet) %>%
  knitr::kable()
```

W trakcie realizacji projektu koszty są:

- wynagrodzeń z umów cywilno-prawnych: przeważnie na twardo przypisane do zadań
- konferencje, książki, wynagrodzenia etatowe nie koniecznie jednoznacznie przypisane do zadań

```{r}
d <- expand.grid(
  r=1:2,
  k=1:2,
  stringsAsFactors = FALSE
)
d$n <- c(20,10,15,30)

pop <- mouter(
  r = c('1'=0.6, '2'=0.4),
  k = c('1'=0.5, '2'=0.5),
  retval = "df",
  freq_var = "P"
) %>%
  mutate(
    r=as.numeric(r),
    k=as.numeric(k),
    N = P * 100
  ) %>%
  left_join(d) %>%
  mutate(
    r1k1 = r==1 & k==1
  )



mod <- glm(N ~ r + k, offset=log(n), data=pop, family=poisson("log"))
pop$fitted <- predict(mod, pop, type="response")

pop %>% 
  group_by(r) %>%
  summarise_each(
    funs(sum), N, n, fitted
  )

pop %>% 
  group_by(k) %>%
  summarise_each(
    funs(sum), N, n, fitted
  )
```












```{r eval=FALSE}
# Fitting log-linear models with offset and structural zeros

d <- expand.grid(
  r = factor(1:3),
  k = factor(1:2)
)
d$n <- c(10, 20, 30, 10, 50, 10)
d$fixed <- c(0, 1, 0, 0, 1, 0)
d$ff <- factor(replace(d$fixed, which(d$fixed == 1), seq(along=which(d$fixed == 1))))

# unconstrained
m0 <- glm( n ~ r + k, data=d, family=poisson("log"))
d$p0 <- predict(m0, type="response")

# fixing cell values
m1 <- update(m0, . ~ . + ff)
d$p1 <- predict(m1, type="response")

# desired marginals
d$margins <- rep(100, nrow(d))
m2 <- glm( margins ~ r + k + offset(log(n)), data=d)
d$p2 <- predict(m2, type="response")

d %>% 
  dplyr::select(n, p0, p1, margins, p2) %>%
  summarise_each( funs(sum))
d %>% 
  group_by(r) %>%
  dplyr::select(n, p0, p1, margins, p2) %>%
  summarise_each( funs(sum))
d %>% 
  group_by(k) %>%
  dplyr::select(n, p0, p1, margins, p2) %>%
  summarise_each( funs(sum))
```


