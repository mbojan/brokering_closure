---
title: "Budżetowanie"
author: "Michał Bojanowski"
output: 
  html_document:
    highlight: pygments
---

```{r setup, include=FALSE, cache=FALSE}
library(tibble)
library(dplyr)

set.seed(0)
```

Budżet wymaga:

1. Harmonogram: łączne koszty zadań.
2. Kosztorys: łączne koszty przez lata w rozbiciu na osobowe i nieosobowe.
3. Personel: łączne koszty zatrudnienia poszczególnych osób.

W utopijnym świecie każdą złotówkę w projekcie można przyporządkować wg następujących zmiennych:

- `rok` projektu
- `zadanie` projektu
- `osoba` lub ogólnie "kontrahent" (musi obejmować nieosobowe koszty). Dzielą się na `kategoria= "osobowe"` i `kategoria="nieosobowe"`.
- `kategoria` koszty osobowe i nieosobowe

Jednocześnie, prezentacja budżetu wymaga wykazania jedynie czterech rozkładów sum brzegowych:

1. Rozkładu brzegowego `zadanie`
2. Rozkładu brzegowego `rok` x `kategoria`
3. Rozkładu brzegowego `osoba`

Przykładowy budżet jako rozkład łączny:

```{r dane}
load("recon.rda")

head(budzet) %>%
  knitr::kable()
```

W trakcie realizacji projektu koszty są:

- wynagrodzeń z umów cywilno-prawnych: przeważnie na twardo przypisane do zadań
- konferencje, książki, wynagrodzenia etatowe nie koniecznie jednoznacznie przypisane do zadań

```{r}
d <- expand.grid(
  r=0:1,
  k=0:1,
  stringsAsFactors = FALSE
)
d$n <- c(20,10,15,30)

margins <- list(
  r = c('0'=35, '1'=40),
  k = c('0'=30, '1'=45)
)
margins <- lapply(margins, function(x) x / 75 )

pop <- with(margins, outer(r, k)) %>%
  as.table() %>%
  as_data_frame() %>%
  rename(r=Var1, k=Var2, p=n) %>%
  mutate(
    r = as.numeric(r),
    k = as.numeric(k),
    N = p * 75
    ) %>%
  left_join(d)


mod <- glm(N ~ r + k, offset=log(n), data=pop, family=poisson("log"))
pop$fitted <- predict(mod, pop, type="response")

pop %>% 
  group_by(r) %>%
  summarise_each(
    funs(sum), N, n, fitted
  )

pop %>% 
  group_by(k) %>%
  summarise_each(
    funs(sum), N, n, fitted
  )
```


```{r mouter}
mouter <- function(..., retval=c("df", "array"), freq_var="n") {
  retval <- match.arg(retval)
  args <- list(...)
  
  # Sanity checks
  is_atom <- sapply(args, is.atomic)
  if(any(!is_atom))
    stop("elements ", paste(which(!is_atom), collapse=", "), " are not atomic")
  is_num <- sapply(args, is.numeric)
  if(any(!is_num))
    stop("elements ", paste(which(!is_num), collapse=", "), " are not numeric")
  
  # Reduce!
  rval <- Reduce(outer, args)
  
  # Fix variable names
  var_names <- function(l) {
    lapply( seq(along=l), function(i) {
      d <- dim(l[[i]])
      if(length(d) > 1) return(names(dimnames(l[[i]])))
      else return(names(l[i]))
    } )
  }
  names(dimnames(rval)) <- unlist(var_names(args))

  # Return
  if(retval == "df") {
    rval <- as.data.frame(as.table(rval), stringsAsFactors=FALSE)
    names(rval)[length(rval)] <- freq_var
  }
  return(rval)
}



x <- mouter(
  A = c(a=1, b=2) / 3,
  M = matrix(1:4 / 10, 2, 2, dimnames=list(D=letters[5:6], E=letters[7:8])),
  B = c(c=2, d=3) / 5,
  retval="a"
) * 1000

as.table(x) %>%
  as_data_frame()
```

